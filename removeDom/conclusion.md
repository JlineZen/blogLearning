### 删除DOM节点

* 1、什么叫内存泄漏？
程序在运行的过程需要内存，只要程序提出需求，操作系统会提供内存，对于持续服务的进程，如果内存得不到必要时的及时清除及释放，则会造成内存占用越来越高，从而影响系统性能。

* 2、JS的内存回收机制是什么？[垃圾回收机制](http://www.jb51.net/article/75292.htm)
js的内存回收机制分为两种：引用计数和标记清除；
1、标记清除是在指当变量进入环境中，例如：当函数中声明一个变量，就在这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入函数中的变量所占用内存，因为只要进入相应的环境，就有可能会用到它们。而当变量离开环境时，则标记为“离开环境”。垃圾回收机制会在运行时候给存储在内存中的变量加上标记，然后会去掉环境中的变量及变量引用的变量的标记（闭包）。而在此之后被加上标记的变量会被视为删除的变量，因为这些变量在环境中可能无法访问这些变量了，最后GC会回收这些变量的内存。
2、引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

	**IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。**

```javascript
	var element = document.getElementById("some_element")
	var myObject = new Object()
	myObject.e = element
	element.o = myObject
```

这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名为o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。

* 2、JS在什么情况下会引起内存泄漏？
	* 对象循环引用
	```javascript	
		// 循环引用会造成内存泄漏
		var a = new Object()
		var b = new Object() 
		a.someProperty = b
		b.someProperty = a
	```

* 3、删除节点在IE中为何可能引起内存泄漏？

* 4、!+'\v1' 代表什么意思？

这是区分IE浏览器与其他浏览器的一个方法。因为在IE浏览器中，它无法识别'\v'制表符，所以在IE中hi被解释成'\v1'字符串，而中其他浏览器中，'\v1'会别被识别为1数字类型。所以 !+'\v1'就是v1字符串转换成数字类型成为NaN，而非NaN的布尔型则true。